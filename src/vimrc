set nocompatible " enable lots of cool vim-only features
filetype off " required for vundle setup

" set up vundle iteself
set rtp+=~/.vim/bundle/vundle/
call vundle#rc()

" let Vundle manage Vundle required!
Bundle 'gmarik/vundle'

" and let's add some vundles
Bundle "ervandew/supertab"
Bundle "grayrest/vim-coffee-script"
Bundle "kana/vim-textobj-user"
Bundle "michaeljsmith/vim-indent-object"
Bundle "mileszs/ack.vim"
Bundle "nelstrom/vim-textobj-rubyblock"
Bundle "othree/html5-syntax.vim"
Bundle "pangloss/vim-javascript"
Bundle "sickill/vim-pasta"
Bundle "tpope/vim-commentary"
Bundle "tpope/vim-endwise"
Bundle "tpope/vim-eunuch"
Bundle "tpope/vim-fugitive"
Bundle "tpope/vim-git"
Bundle "tpope/vim-liquid"
Bundle "tpope/vim-rails"
Bundle "tpope/vim-rake"
Bundle "tpope/vim-repeat"
Bundle "tpope/vim-surround"
Bundle "tpope/vim-unimpaired"
Bundle "vim-ruby/vim-ruby"
Bundle "vim-scripts/ZoomWin"
Bundle "w0ng/vim-hybrid"
Bundle "ctrlp.vim"
Bundle "bufexplorer.zip"
Bundle "sjl/strftimedammit.vim"
Bundle "tpope/vim-characterize"
Bundle "tpope/vim-markdown"
Bundle "rizzatti/funcoo.vim"
Bundle "rizzatti/dash.vim"
Bundle "slim-template/vim-slim"

" general
"let mapleader = ","
syntax enable " enable syntax highlighting
set encoding=utf-8 " default encoding
set showcmd " display incomplete commands
filetype plugin indent on " load file type plugins and indentation
set showmatch " highlight the matching {("/")}
set backupdir=~/.vim/_backup " specify location for backup files
set directory=~/.vim/_swp " specify location for swp files
set relativenumber " relative line numbers; if you care about aboslute, look at the status bar
set cursorline " highlight the current line
" set autoindent " perform auto-indentation
set shiftround " round to the nearest tabstop when tabbing
set scrolloff=3 " start scrolling within 3 lines of the edge of the window
set title " show a window title, even in command-line vim
set visualbell " eliminate audio bells
set hidden " allow an unsaved buffer to become hidden (no longer the visible), and load its marks and undo history upon becoming visible again
set history=1000 " store command history FOREVER

" whitespace settings
set nowrap " don't wrap lines
set tabstop=2 shiftwidth=2 softtabstop=2 " 2 spaces for tabs
set expandtab " use spaces, not tabs
set backspace=indent,eol,start " backspace through everything
set list " display whitespace characters
set listchars=tab:\ \ ,trail:· " tabs, spaces, trailing whitespace

" searching
set hlsearch " highlight matches
set incsearch " search incrementally
set ignorecase " case-insensitive search
set smartcase " unless there's a capital later

" status bar
set ruler " enable status bar at the bottom
set laststatus=2 " Status bar
" eliminate some extraneous garbage from messages
" a to truncate text as much as possible
" t to eliminate long file names
" I to skip vim's intro message
set shortmess=atI

" Tab completion
set wildmenu " enable tab completion
set wildmode=list:longest,list:full " promiscuous selection of available completions
set wildignore+=*.o,*.obj,.git,*.rbc,*.class,.svn " ignore these files for completion
set wildignore+=*.png,*.jpg,*.gif,*.ico,*.swf,*.psd,*.gem " and these binaries, too. mainly for command-t
set wildignore+=_site,cache,tmp " and auto-generated files
set wildignore+=_undo,_swp,_backup " and vim's backups
set wildignore+=node_modules " and npm-installed modules

" window splitting settings
set splitbelow
set splitright

" Default color scheme
set t_Co=256 " 256 colors
set background=dark
" colorscheme lucius
colorscheme hybrid

" Undo settings, if available
if has("persistent_undo")
  set undodir=~/.vim/_undo " specify location of undo files

  set undofile " persistent undo, even after closing and saving
  set undolevels=1000 "maximum number of changes that can be undone
  set undoreload=10000 "maximum number lines to save for undo on a buffer reload
endif

" MacVIM shift+arrow-keys behavior (required in .vimrc)
let macvim_hig_shift_movement = 1

" % to bounce from do to end etc.
" also necessary for textobj-rubyblock
runtime! macros/matchit.vim

" force you to Do The Right Thing (don't use arrows to move)
nnoremap <up> <nop>
nnoremap <down> <nop>
nnoremap <left> <nop>
nnoremap <right> <nop>
inoremap <up> <nop>
inoremap <down> <nop>
inoremap <left> <nop>
inoremap <right> <nop>


" Custom shortcuts
" use sane (not the vim-default) regexes in search
nnoremap / /\v
" use sane (not the vim-default) regexes in search
vnoremap / /\v
" clear the search term
nnoremap <leader><space> :noh<cr>
" close windows other than the current
noremap <Leader>w :ZoomWin<CR>
" shortcuts for beginning and end of the line
nnoremap <Leader>h ^
nnoremap <Leader>l $
" jj to escape insert mode
inoremap jj <ESC>
" ug, and kk because i keep hitting it
inoremap kk <ESC>

" open the .vimrc
noremap <Leader>` :sp $MYVIMRC<CR>
" and reload it automatically when saving it
augroup myvimrc
    au!
    au BufWritePost .vimrc,_vimrc,vimrc,.gvimrc,_gvimrc,gvimrc so $MYVIMRC | if has('gui_running') | so $MYGVIMRC | endif
augroup END

" save really quickly
" noremap <cr> :w<cr>

" emulate MacVim keybindings
noremap <Leader>s :w<CR>
inoremap <Leader>s <ESC>:w<CR>
noremap <Leader>S :W<CR>
noremap <Leader>S <ESC>:W<CR>i
" the "* register is the system clipboard
" cut the selection, if selected
vnoremap <Leader>x "*d
" cut the line if not in selection
nnoremap <Leader>x "*dd
inoremap <Leader>x <ESC>"*di
" copy the selection, if selected
vnoremap <Leader>c "*y
" copy the line, if not in selection
nnoremap <Leader>c "*yy
inoremap <Leader>c <ESC>"*yi
" paste
noremap <Leader>v "*p
inoremap <Leader>v <ESC>"*pi
" paste before
noremap <Leader>V "*P
inoremap <Leader>V <ESC>"*Pi

" automatically strip whitespace from ends of ruby and ERB files
"autocmd BufWritePre *.rb,*.erb :%s/\s\+$//e
nnoremap <Leader>WS :%s/\s\+$//e<CR>

if $VIM_CRONTAB == "true"
set nobackup " don't back up, causes issues editing crontabs
set nowritebackup " disabling other backup feature
syntax off " my colorscheme's syntax highlighting in crontab is redongculous
endif

set statusline=%<%f\ %h%m%r%=%y\ %-14.(%l,%c%V%)\ %P

" Unimpaired shortcuts
" Bubble single lines
nnoremap <C-Up> [e
nnoremap <C-Down> ]e
" Bubble multiple lines
vnoremap <C-Up> [egv
vnoremap <C-Down> ]egv

" CTags shortcuts
noremap <Leader>rt :!ctags --extra=+f -R *<CR><CR>
" open definition in a new tab
noremap <C-\> :sp <CR>:exec("tag ".expand("<cword>"))<CR>

" test running
" lifted from https://github.com/garybernhardt/dotfiles/blob/master/.vimrc
noremap <leader>t :call RunTest()<cr>
" inoremap <leader>t <esc>:call RunTest()<cr>

" Run tests in the current file, if the file is a test, or in the last test
" file this was called from.
function! RunTest()
  " Write the file and run tests for the given filename
  if expand("%") != ""
    :w
  end

  let in_test_file = match(expand("%"), '\(_spec.rb\|_test.rb\)') != -1
  if in_test_file
    " capture the path to the test file
    call SetTestFile()
  endif
  if !exists("t:pjb_test_file")
    " if the file doesn't exist, bomb out
    call UnableToRunTest("No test file has been captured. Run this command from a test file.")
    return
  endif

  call RunTestFile(t:pjb_test_file)
endfunction

" Set current file to be the test file to run
function! SetTestFile()
  let t:pjb_test_file=@%
endfunction

" Run the given test file, using the appropriate command
function! RunTestFile(filename)
  if match(a:filename, "_spec") != -1
    " rspec
    let pjb_test_command = ":!bundle exec rspec " . a:filename
  elseif match(a:filename, "_test") != -1
    " test:unit
    if match(a:filename, "/unit/") != -1
      let test_type = "test:units"
    elseif match(a:filename, "/functional/") != -1
      let test_type = "test:functionals"
    elseif match(a:filename, "/integration/") != -1
      let test_type = "test:integration"
    elseif match(a:filename, "/capybara/") != -1
      let test_type = "test:capybara"
    else
      call UnableToRunTest("Unable to determine which type of test:unit test to run for " . a:filename)
      return
    endif

    let pjb_test_command =  ":!bundle exec rake " . test_type . " TEST=" . a:filename
  else
    call UnableToRunTest("Unable to determine a test command for " . a:filename)
    return
  endif

  echo pjb_test_command
  exec pjb_test_command
endfunction

" Bomb out of test run
function! UnableToRunTest(reason)
  exec ":!echo Unable to run test: " . a:reason
endfunction

" function! RunTests(filename)
"     " Write the file and run tests for the given filename
"     :w
"     :silent !echo;echo;echo;echo;echo;echo;echo;echo;echo;echo -----------------------
"     if match(a:filename, '\.feature$') != -1
"         exec ":!script/features " . a:filename
"     else
"         if filereadable("script/test")
"             exec ":!script/test " . a:filename
"         elseif filereadable("Gemfile")
"             exec ":!bundle exec rspec --color " . a:filename
"         else
"             exec ":!rspec --color " . a:filename
"         end
"     end
" endfunction

function! PromoteToLet()
  :normal! dd
  :normal! P
  :.s/\(\w\+\) = \(.*\)$/let(:\1) { \2 }/
  :normal ==
  :normal j
endfunction
:command! PromoteToLet :call PromoteToLet()
:noremap <leader>p :PromoteToLet<cr>

" get out of here!
:command! -bang Q :qa<bang>
:command! -bang WQ :wa | :qa<bang>

" ack
noremap <Leader>a :Ack<space>
" ack for current word (based on cursor)
noremap <Leader>A :Ack<space><C-r><C-w>

" disable some delimitmate mappings which cause a delay when hitting <ESC>O
" (which creates a new line above the current, while in insert mode)
let delimitMate_no_esc_mapping = 1

" make %% map to the directory path containing the current file
cnoremap %% <C-R>=expand('%:h').'/'<cr>

" Create parent directories for the current file
command! Mkdirs silent exe ':silent !mkdir -p %:h' | redraw!

" Leader-][ to increase/decrease indentation
vnoremap > >gv
vnoremap < <gv

" Move around splits with <c-hjkl>
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l
" loop through the open windows
nnoremap <c-i> <c-w>w


if has("autocmd")
  " Remember last location in file
  autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
    \| exe "normal g'\"" | endif

  " maps .. to move up a directory when in Fugitive's Gedit view on a folder
  autocmd User fugitive
    \ if fugitive#buffer().type() =~# '^\%(tree\|blob\)$' |
    \   nnoremap <buffer> .. :edit %:h<CR> |
    \ endif

  " delete a Gedit view from the buffer list when leaving it
  autocmd BufReadPost fugitive://* set bufhidden=delete

  " exit out of vimdiff mode from a fugitive diff, ugly and hacky but it works
  " from http://stackoverflow.com/questions/2703644/how-do-you-exit-vimdiff-mode-in-vim
  function! MyCloseDiff()
    if (&diff == 0 || getbufvar('#', '&diff') == 0)
          \ && (bufname('%') !~ '^fugitive:' && bufname('#') !~ '^fugitive:')
      echom "Not in diff view."
      return
    endif

    " close current buffer if alternate is not fugitive but current one is
    if bufname('#') !~ '^fugitive:' && bufname('%') =~ '^fugitive:'
      if bufwinnr("#") == -1
        b #
        bd #
      else
        bd
      endif
    else
      bd #
    endif
  endfunction
  nnoremap <Leader>dd :call MyCloseDiff()<cr>

  " make uses real tabs
  autocmd FileType make set noexpandtab

  " Thorfile, Rakefile, Vagrantfile and Gemfile are Ruby
  autocmd BufRead,BufNewFile {Gemfile,Rakefile,Vagrantfile,Thorfile,config.ru,*.term,Guardfile}    set ft=ruby

  " *.md are markdown
  autocmd BufRead,BufNewFile *.md set ft=markdown

  " json is really just javascript
  autocmd BufNewFile,BufRead *.json set ft=javascript

  " clean up quickfix (e.g., Ack) output
  autocmd Filetype qf setlocal colorcolumn=0 nolist nocursorline nowrap

  " make python follow PEP8 ( http://www.python.org/dev/peps/pep-0008/ )
  autocmd FileType python  set tabstop=4 textwidth=79

  " hard tabs for git configs, to make consistent with how the git tool writes
  autocmd FileType gitconfig set tabstop=4 shiftwidth=4 noexpandtab

  " For some reason, iskeyword gets set differently sometimes on ruby files,
  " not splitting on '.' or ':', which makes namespaces and methods names a
  " pain to autocomplete or modify. This ensures that iskeyword is always
  " consistent until I figure out what's going wrong.
  autocmd FileType ruby set iskeyword=@,48-57,_,192-255

  " check spelling from within git commit messages
  autocmd FileType gitcommit setlocal spell

  " automatically leave insert mode after 15 seconds of inactivity
  autocmd CursorHoldI * stopinsert
  autocmd InsertEnter * let updaterestore=&updatetime | set updatetime=15000
  autocmd InsertLeave * let &updatetime=updaterestore
endif

"""""""""""""""""""""""""""""""
" Highlight Trailing Whitespace
"""""""""""""""""""""""""""""""

highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()

" when doing line wrap, prepend with a fancy character to distinguish from the
" next actual line
set showbreak=↪

" load my zsh settings
" turned off until i figure out why this is causing vim to suspend all the time
" set shell=/bin/zsh
" set shellcmdflag=-ci

" Only show cursorline in the current window and in normal mode.
augroup cline
  au!
  au WinLeave,InsertEnter * set nocursorline
  au WinEnter,InsertLeave * set cursorline
augroup END

" Try using the silver searcher instead of ack
let g:ackprg = 'ag --nogroup --nocolor --column'

set shell=/bin/sh

" Open the current file with the :Marked command
command! Marked silent exe "!open -a Marked.app '%:p'" | redraw!

" create first- and second-level markdown headings
" copy the current line to the line below, replace with an equal number of =
noremap <Leader>1 yypVr=
noremap <Leader>2 yypVr-

" Add go-supplied syntax highlighting
set rtp+=/usr/local/Cellar/go/1.2/libexec/misc/vim
au BufRead,BufNewFile *.go set filetype=go
" Run the current .go file with <leader>g
autocmd FileType go nnoremap <leader>g :w<cr>:!go run %<cr>
